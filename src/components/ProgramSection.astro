---
import { getCollection } from "astro:content";
import { Image } from "astro:assets";
import Parallax from "./ui/Paralax";

const programItems = await getCollection('program');
---

<section class="pt-2 md:pt-7 lg:pt-[150px] relative" id="program">
  <Parallax className="hidden sm:block absolute left-0 top-0" speed={1} client:visible>
    <svg width="192" height="320" viewBox="0 0 192 320" fill="none" xmlns="http://www.w3.org/2000/svg">
      <g opacity="0.75" filter="url(#filter0_f_1647_405)">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M29.9453 304.023L78.7355 267.45L73.7538 207.682L24.9636 244.254L29.9453 304.023ZM122.546 171.108L171.334 134.537L176.316 194.306L127.525 230.878L122.544 171.111L73.7559 207.682L68.7741 147.913L117.564 111.341L122.546 171.108ZM117.563 111.341L166.353 74.7686L161.371 14.9999L112.581 51.5722L117.563 111.341ZM68.7726 147.913L19.9824 184.485L15.0007 124.717L63.7909 88.1444L68.7726 147.913Z" fill="#FF0C49"/>
      </g>
      <defs>
        <filter id="filter0_f_1647_405" x="0" y="0" width="191.316" height="319.023" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
          <feFlood flood-opacity="0" result="BackgroundImageFix"/>
          <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
          <feGaussianBlur stdDeviation="7.5" result="effect1_foregroundBlur_1647_405"/>
        </filter>
      </defs>
    </svg>
  </Parallax>

  <Parallax className="hidden sm:block absolute left-0 top-0" speed={0.5} client:visible>
    <svg width="302" height="664" viewBox="0 0 302 664" fill="none" xmlns="http://www.w3.org/2000/svg">
      <g opacity="0.5" filter="url(#filter0_f_1647_267)">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M15.8906 648.471L99.1383 573.299L106.185 437.432L22.937 512.603L15.8906 648.471ZM189.435 362.256L272.677 287.089L265.631 422.957L182.383 498.128L189.429 362.265L106.187 437.432L113.233 301.564L29.9854 376.736L37.0317 240.868L120.279 165.697L113.233 301.564L196.481 226.393L189.435 362.256ZM196.478 226.393L279.726 151.221L286.772 15.3538L203.524 90.5252L196.478 226.393Z" fill="#FF0C49"/>
      </g>
      <defs>
        <filter id="filter0_f_1647_267" x="0.890625" y="0.35376" width="300.883" height="663.117" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
          <feFlood flood-opacity="0" result="BackgroundImageFix"/>
          <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
          <feGaussianBlur stdDeviation="7.5" result="effect1_foregroundBlur_1647_267"/>
        </filter>
      </defs>
    </svg>
  </Parallax>
  <h2
class="text-xl md:text-2xl lg:text-3xl xl:text-4xl text-center font-bold uppercase font-display italic"
>
    Приходи на ратата
</h2>
  <h2
class="text-lg md:text-xl lg:text-2xl xl:text-3xl text-center font-bold uppercase font-display italic"
>
Мы покажем, как:
</h2>
</section>

<div id="container" class="max-w-5xl mx-auto w-full px-2 py-7 flex lg:py-8 lg:px-0 lg:pt-[150px]">
  <div class="lg:w-1/2 space-y-16 text-white text-2xl">
    {
      programItems.map((item, i) => (
        <div
          class="program-item lg:pb-10 lg:pr-3 group"
          class:list={i === 0 ? "active-item" : ""}
        >
          <div class="flex items-center gap-5 mb-2 lg:mb-0">
            <svg
              width="64"
              height="44"
              viewBox="0 0 64 44"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
              class="stroke-secondary group-[.active-item]:stroke-accent"
            >
              <path d="M2 18.5L24 40.5L62.5 2" stroke-width="4" />
            </svg>
            <span class="text-sm lg:text-[30px] font-bold text-secondary group-[.active-item]:text-accent">
              {item.data.label}
            </span>
          </div>
          <div class="bg-midnight program-content text-white grayscale transition lg:hidden group-[.active-item]:grayscale-0">
            <Image src={item.data.img} alt={item.data.label} class="w-full mb-3"/>
            <div class="p-3">
              <p class="text-sm text-white">{item.data.text}</p>
            </div>
          </div>
        </div>
      ))
    }
  </div>
  <div
    id="text"
    class="hidden lg:block lg:w-1/2 bg-midnight program-content text-white h-[400px]"
  >
    <Image src={programItems[0].data.img} alt={programItems[0]} class="w-full mb-3"/>
    <div class="p-3">
      <p class="text-sm">{programItems[0].data.text}</p>
    </div>
  </div>
</div>

<script>
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";
  gsap.registerPlugin(ScrollTrigger);
  const mm = gsap.matchMedia();
  let boxes = gsap.utils.toArray(".program-item");
  let container = document.querySelector("#container");
  let text = document.querySelector("#text");
  let padding = gsap.getProperty(container, "paddingTop", "px");

  mm.add("(min-width: 1024px)", () => {
      // create a ScrollTrigger for each box that we can use to calculate snapping (we'll look at the "start" of each in the onRefresh)
      let snapTriggers = boxes.map((box) =>
        ScrollTrigger.create({
          trigger: box,
          start: "top " + padding + "px",
        })
      ),
      snaps = []; // where we'll store the progress value for each box's ScrollTrigger (start)

    ScrollTrigger.create({
      trigger: "#container",
      pin: "#text",
      start: "top top",
      end: () =>
        "+=" +
        (boxes[boxes.length - 1].getBoundingClientRect().top -
          boxes[0].getBoundingClientRect().bottom),
      onRefresh: (self) => {
        // re-populate the "snaps" Array with the progress values for where each box hits the target spot.
        // let distance = self.end - self.start;
        // snapTriggers.forEach(
        //   (trigger, i) => (snaps[i] = (trigger.start - self.start) / distance)
        // );
      },
      snap: snaps,
    });

    // for swapping in the text for each section
    boxes.forEach((box, i) => {
      ScrollTrigger.create({
        trigger: box,
        start: "top center",
        end: "bottom+=50 center",
        onEnterBack: () => {
          box.classList.add("active-item");
        },
        onEnter: () => {
          box.classList.add("active-item");
        },
        onLeave: () => {
          box.classList.remove("active-item");
        },
        onLeaveBack: () => {
          box.classList.remove("active-item");
        },
        onToggle: (self) => {
          if (self.isActive) {
            // you could animate this in (fade it or whatever)
            const content = box.children[1];
            text.innerHTML = content.innerHTML;
          }
        },
      });
    });
  });

  mm.add("(max-width: 1023px)", () => {
    boxes.forEach((item: HTMLElement) => {
      ScrollTrigger.create({
        trigger: item,
        start: "top center",
        end: "bottom center-=100",
        onEnterBack: () => {
          item.classList.add("active-item");
        },
        onEnter: () => {
          item.classList.add("active-item");
        },
        onLeave: () => {
          item.classList.remove("active-item");
        },
        onLeaveBack: () => {
          item.classList.remove("active-item");
        },
      });
    });
  });
</script>
